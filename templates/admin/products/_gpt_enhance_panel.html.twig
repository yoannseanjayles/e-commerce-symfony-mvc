{#
  Injected into EasyAdmin Products new/edit forms.
  Renders a non-destructive "‚ú® Am√©liorer avec GPT" helper.
#}

<div class="content-panel" id="gpt-enhance-panel"
    data-endpoint="{{ path('admin_product_gpt_suggest') }}"
    data-csrf="{{ csrf_token('admin_product_gpt_suggest') }}"
    data-fields-endpoint="{{ path('admin_product_gpt_suggest_fields') }}"
    data-fields-csrf="{{ csrf_token('admin_product_gpt_suggest_fields') }}"
    data-images-suggest-endpoint="{{ path('admin_product_gpt_suggest_images') }}"
    data-images-suggest-csrf="{{ csrf_token('admin_product_gpt_suggest_images') }}"
    data-variants-suggest-endpoint="{{ path('admin_product_gpt_suggest_variants') }}"
    data-variants-suggest-csrf="{{ csrf_token('admin_product_gpt_suggest_variants') }}"
    data-is-edit="{{ pageName is defined and pageName == 'edit' ? '1' : '0' }}"
    data-product-id="{{ entity.primaryKeyValue|default('') }}"
    data-images-endpoint="{{ pageName is defined and pageName == 'edit' ? path('admin_product_ai_images_add', {id: entity.primaryKeyValue|default(0)}) : '' }}"
    data-images-csrf="{{ csrf_token('admin_product_ai_images_add') }}"
    data-images-stage-endpoint="{{ path('admin_product_ai_images_stage') }}"
    data-images-stage-csrf="{{ csrf_token('admin_product_ai_images_stage') }}"
    data-variants-endpoint="{{ pageName is defined and pageName == 'edit' ? path('admin_product_ai_variants_create', {id: entity.primaryKeyValue|default(0)}) : '' }}"
    data-variants-csrf="{{ csrf_token('admin_product_ai_variants_create') }}"
    data-variant-images-endpoint="{{ pageName is defined and pageName == 'edit' ? path('admin_product_ai_variant_images_add', {id: entity.primaryKeyValue|default(0)}) : '' }}"
    data-variant-images-csrf="{{ csrf_token('admin_product_ai_variant_images_add') }}">
    <div class="content-panel-header">
        <h3 class="content-panel-title">‚ú® Am√©liorer avec GPT</h3>
    </div>
    <div class="content-panel-body">
        <div class="row g-2 align-items-end">
            <div class="col-12 col-md-4">
                <label class="form-label" for="gpt-aggressiveness">‚öôÔ∏è Niveau d‚Äôagressivit√©</label>
                <select class="form-select" id="gpt-aggressiveness">
                    <option value="light">l√©ger</option>
                    <option value="medium" selected>moyen</option>
                    <option value="strong">fort</option>
                </select>
            </div>
            <div class="col-12 col-md-4">
                <div class="form-check mt-4">
                    <input class="form-check-input" type="checkbox" value="1" id="gpt-web-search">
                    <label class="form-check-label" for="gpt-web-search">üîé Rechercher sur le web</label>
                </div>
            </div>
            <div class="col-12 col-md-2">
                <label class="form-label" for="gpt-max-images">üñºÔ∏è Nb images (suggestion)</label>
                <input class="form-control" id="gpt-max-images" type="number" min="1" max="30" value="20" />
            </div>
            <div class="col-12 col-md-2">
                <label class="form-label" for="gpt-variant-image-count">üé® Nb images / variante</label>
                <input class="form-control" id="gpt-variant-image-count" type="number" min="1" max="10" value="1" />
            </div>
            <div class="col-12 col-md-12 text-md-end">
                <button type="button" class="btn btn-primary" id="gpt-enhance-btn">‚ú® Am√©liorer avec GPT</button>
            </div>
        </div>

        <div class="mt-3" id="gpt-enhance-status" style="display:none;"></div>

        <div class="mt-3" id="gpt-diff" style="display:none;">
            <div class="d-flex gap-2 flex-wrap mb-2">
                <button type="button" class="btn btn-outline-primary btn-sm" id="gpt-apply-empty">Appliquer uniquement les champs vides</button>
                <button type="button" class="btn btn-outline-primary btn-sm" id="gpt-apply-selected">Appliquer s√©lection</button>
                <button type="button" class="btn btn-outline-secondary btn-sm" id="gpt-copy-description">Copier la description</button>
                <button type="button" class="btn btn-outline-success btn-sm" id="gpt-download-images" style="display:none;">T√©l√©charger et ajouter ces images</button>
                <button type="button" class="btn btn-outline-success btn-sm" id="gpt-create-variants" style="display:none;">Cr√©er variantes propos√©es</button>
                <button type="button" class="btn btn-outline-success btn-sm" id="gpt-generate-variant-images" style="display:none;">G√©n√©rer images pour variantes s√©lectionn√©es</button>
            </div>

            <div class="table-responsive">
                <table class="table table-sm">
                    <thead>
                    <tr>
                        <th style="width: 32px;"></th>
                        <th>Champ</th>
                        <th>Avant</th>
                        <th>Proposition</th>
                    </tr>
                    </thead>
                    <tbody id="gpt-diff-rows"></tbody>
                </table>
            </div>

            <div class="mt-2">
                <div class="small text-muted" id="gpt-sources"></div>
                <div class="small text-muted" id="gpt-notes"></div>
            </div>

            <div class="mt-3" id="gpt-variants" style="display:none;">
                <div class="fw-semibold mb-1">Variantes propos√©es</div>
                <div class="table-responsive">
                    <table class="table table-sm">
                        <thead>
                        <tr>
                            <th style="width: 32px;"></th>
                            <th>Nom</th>
                            <th>Couleur</th>
                            <th>Taille</th>
                            <th>SKU</th>
                            <th>Code-barres</th>
                            <th>Prix</th>
                            <th>Stock</th>
                            <th>Image</th>
                        </tr>
                        </thead>
                        <tbody id="gpt-variants-rows"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
(function () {
    const panel = document.getElementById('gpt-enhance-panel');
    if (!panel) return;

    const fieldsEndpoint = panel.dataset.fieldsEndpoint || panel.dataset.endpoint;
    const fieldsCsrf = panel.dataset.fieldsCsrf || panel.dataset.csrf;
    const imagesSuggestEndpoint = (panel.dataset.imagesSuggestEndpoint || '').toString();
    const imagesSuggestCsrf = (panel.dataset.imagesSuggestCsrf || '').toString();
    const variantsSuggestEndpoint = (panel.dataset.variantsSuggestEndpoint || '').toString();
    const variantsSuggestCsrf = (panel.dataset.variantsSuggestCsrf || '').toString();

    const isEdit = panel.dataset.isEdit === '1';
    const productId = (panel.dataset.productId || '').toString();
    const imagesEndpoint = (panel.dataset.imagesEndpoint || '').toString();
    const imagesCsrf = (panel.dataset.imagesCsrf || '').toString();
    const imagesStageEndpoint = (panel.dataset.imagesStageEndpoint || '').toString();
    const imagesStageCsrf = (panel.dataset.imagesStageCsrf || '').toString();
    const variantsEndpoint = (panel.dataset.variantsEndpoint || '').toString();
    const variantsCsrf = (panel.dataset.variantsCsrf || '').toString();
    const variantImagesEndpoint = (panel.dataset.variantImagesEndpoint || '').toString();
    const variantImagesCsrf = (panel.dataset.variantImagesCsrf || '').toString();

    const btn = document.getElementById('gpt-enhance-btn');
    const statusEl = document.getElementById('gpt-enhance-status');
    const diffEl = document.getElementById('gpt-diff');
    const rowsEl = document.getElementById('gpt-diff-rows');
    const sourcesEl = document.getElementById('gpt-sources');
    const notesEl = document.getElementById('gpt-notes');
    const variantsEl = document.getElementById('gpt-variants');
    const variantsRowsEl = document.getElementById('gpt-variants-rows');

    const aggressivenessEl = document.getElementById('gpt-aggressiveness');
    const webSearchEl = document.getElementById('gpt-web-search');
    const maxImagesEl = document.getElementById('gpt-max-images');
    const variantImageCountEl = document.getElementById('gpt-variant-image-count');

    const applyEmptyBtn = document.getElementById('gpt-apply-empty');
    const applySelectedBtn = document.getElementById('gpt-apply-selected');
    const copyDescriptionBtn = document.getElementById('gpt-copy-description');
    const downloadImagesBtn = document.getElementById('gpt-download-images');
    const createVariantsBtn = document.getElementById('gpt-create-variants');
    const generateVariantImagesBtn = document.getElementById('gpt-generate-variant-images');

    if (!fieldsEndpoint || !fieldsCsrf || !btn || !statusEl || !diffEl || !rowsEl || !sourcesEl || !notesEl || !aggressivenessEl || !webSearchEl || !applyEmptyBtn || !applySelectedBtn || !copyDescriptionBtn || !variantsEl || !variantsRowsEl || !downloadImagesBtn || !createVariantsBtn || !generateVariantImagesBtn || !maxImagesEl || !variantImageCountEl) return;

    function clampInt(v, min, max, fallback) {
        const n = parseInt((v ?? '').toString(), 10);
        if (isNaN(n)) return fallback;
        return Math.max(min, Math.min(max, n));
    }

    function getMainForm() {
        return document.querySelector('form.ea-new-form')
            || document.querySelector('form.ea-edit-form')
            || document.querySelector('form[name="Products"]')
            || document.querySelector('form');
    }

    function setStagedImagesToken(token) {
        const form = getMainForm();
        if (!form) return;

        let input = form.querySelector('input[name="gpt_staged_images_token"]');
        if (!input) {
            input = document.createElement('input');
            input.type = 'hidden';
            input.name = 'gpt_staged_images_token';
            form.appendChild(input);
        }
        input.value = (token || '').toString();
    }

    const fieldSelectors = {
        name: '[name$="[name]"]',
        slug: '[name$="[slug]"]',
        brand: '[name$="[brand]"]',
        color: '[name$="[color]"]',
        barcode: '[name$="[barcode]"]',
        description: '[name$="[description]"]',
        price: '[name$="[price]"]',
        stock: '[name$="[stock]"]',
        category: '[name$="[categories]"]',

        // Opticien
        productType: '[name$="[productType]"]',
        gender: '[name$="[gender]"]',
        frameShape: '[name$="[frameShape]"]',
        frameMaterial: '[name$="[frameMaterial]"]',
        frameStyle: '[name$="[frameStyle]"]',
        lensWidthMm: '[name$="[lensWidthMm]"]',
        bridgeWidthMm: '[name$="[bridgeWidthMm]"]',
        templeLengthMm: '[name$="[templeLengthMm]"]',
        lensHeightMm: '[name$="[lensHeightMm]"]',
        polarized: '[name$="[polarized]"]',
        prescriptionAvailable: '[name$="[prescriptionAvailable]"]',
        uvProtection: '[name$="[uvProtection]"]'
    };

    const fieldMeta = {
        name: { type: 'text' },
        slug: { type: 'text' },
        brand: { type: 'text' },
        color: { type: 'select' },
        barcode: { type: 'text' },
        description: { type: 'textarea' },
        price: { type: 'price' },
        stock: { type: 'int' },
        category: { type: 'select' },

        // Opticien
        productType: { type: 'select' },
        gender: { type: 'select' },
        frameShape: { type: 'text' },
        frameMaterial: { type: 'text' },
        frameStyle: { type: 'text' },
        lensWidthMm: { type: 'int' },
        bridgeWidthMm: { type: 'int' },
        templeLengthMm: { type: 'int' },
        lensHeightMm: { type: 'int' },
        polarized: { type: 'bool' },
        prescriptionAvailable: { type: 'bool' },
        uvProtection: { type: 'text' }
    };

    function qs(selector) {
        return document.querySelector(selector);
    }

    function getFieldValue(field) {
        const el = qs(fieldSelectors[field]);
        if (!el) return '';
        if (el.tagName === 'SELECT') {
            const opt = el.options && el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null;
            return opt ? (opt.textContent || '').toString() : '';
        }
        if (el.type === 'checkbox') {
            return el.checked ? 'true' : 'false';
        }
        return (el.value || '').toString();
    }

    function getFieldSendValue(field) {
        const el = qs(fieldSelectors[field]);
        if (!el) return '';
        if (el.tagName === 'SELECT') {
            // Send label (not raw value) so GPT proposes something we can map back by label.
            return getFieldValue(field);
        }
        if (el.type === 'checkbox') {
            return !!el.checked;
        }
        return (el.value || '').toString();
    }

    function parseBool(value) {
        if (typeof value === 'boolean') return value;
        const t = (value ?? '').toString().trim().toLowerCase();
        if (['1', 'true', 'yes', 'oui'].includes(t)) return true;
        if (['0', 'false', 'no', 'non'].includes(t)) return false;
        return null;
    }

    function setFieldValue(field, value) {
        const el = qs(fieldSelectors[field]);
        if (!el) return;
        if (el.tagName === 'SELECT') {
            const target = (value || '').toString().trim().toLowerCase();
            if (target !== '') {
                // First try by option label.
                for (const opt of Array.from(el.options || [])) {
                    const label = (opt.textContent || '').toString().trim().toLowerCase();
                    if (label === target) {
                        el.value = opt.value;
                        el.dispatchEvent(new Event('change', { bubbles: true }));
                        return;
                    }
                }
                // Then try by raw value.
                el.value = value;
            }
        } else if (el.type === 'checkbox') {
            const b = parseBool(value);
            if (b !== null) {
                el.checked = b;
            }
        } else {
            el.value = value;
        }
        el.dispatchEvent(new Event('input', { bubbles: true }));
        el.dispatchEvent(new Event('change', { bubbles: true }));
    }

    function isBlank(value) {
        return !value || value.trim() === '';
    }

    function showStatus(kind, text) {
        statusEl.className = 'alert alert-' + kind;
        statusEl.textContent = text;
        statusEl.style.display = 'block';
    }

    function clearStatus() {
        statusEl.style.display = 'none';
        statusEl.textContent = '';
        statusEl.className = '';
    }

    function escapeText(value) {
        const div = document.createElement('div');
        div.textContent = value;
        return div.innerHTML;
    }

    let lastSuggestion = null;
    let mergedSources = [];
    let mergedNotes = [];

    function updateMetaDisplay() {
        sourcesEl.textContent = mergedSources.length ? ('sources: ' + mergedSources.join(' | ')) : 'sources: (aucune)';
        notesEl.textContent = mergedNotes.length ? ('notes: ' + mergedNotes.join(' | ')) : 'notes: (aucune)';
    }

    function mergeMeta(payload) {
        const sources = Array.isArray(payload && payload.sources) ? payload.sources : [];
        const notes = Array.isArray(payload && payload.notes) ? payload.notes : [];

        for (const s of sources) {
            if (typeof s === 'string' && !isBlank(s) && !mergedSources.includes(s)) {
                mergedSources.push(s);
            }
        }
        for (const n of notes) {
            if (typeof n === 'string' && !isBlank(n)) {
                mergedNotes.push(n);
            }
        }
        updateMetaDisplay();
    }

    function createProposedInput(field, value) {
        const meta = fieldMeta[field] || { type: 'text' };

        if (meta.type === 'bool') {
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.className = 'form-check-input gpt-proposed-input';
            const b = parseBool(value);
            input.checked = b === null ? false : b;
            return input;
        }

        const v = (value ?? '').toString();

        if (meta.type === 'textarea' || field === 'description') {
            const textarea = document.createElement('textarea');
            textarea.className = 'form-control form-control-sm gpt-proposed-input';
            textarea.rows = 6;
            textarea.value = v;
            return textarea;
        }

        const input = document.createElement('input');
        input.className = 'form-control form-control-sm gpt-proposed-input';
        input.value = v;

        if (meta.type === 'price' || field === 'price') {
            input.type = 'number';
            input.step = '0.01';
            input.min = '0';
        } else if (meta.type === 'int' || field === 'stock') {
            input.type = 'number';
            input.step = '1';
            input.min = '0';
        } else {
            input.type = 'text';
        }

        return input;
    }

    function clearImageRows() {
        for (const tr of Array.from(rowsEl.querySelectorAll('tr[data-section="images"], tr[data-section="images-header"], tr[data-section="images-empty"]'))) {
            tr.remove();
        }
    }

    function clearVariantRows() {
        variantsRowsEl.innerHTML = '';
        variantsEl.style.display = 'none';
        createVariantsBtn.style.display = 'none';
    }

    function renderFields(payload) {
        lastSuggestion = lastSuggestion || {};
        lastSuggestion.suggested = payload && payload.suggested ? payload.suggested : {};
        lastSuggestion.confidence = payload && payload.confidence ? payload.confidence : {};

        rowsEl.innerHTML = '';
        clearVariantRows();
        clearImageRows();
        downloadImagesBtn.style.display = 'none';

        const suggested = lastSuggestion.suggested || {};
        const confidence = lastSuggestion.confidence || {};

        const fields = [
            'name', 'slug', 'brand', 'color', 'barcode', 'description', 'price', 'stock', 'category',
            'productType', 'gender', 'frameShape', 'frameMaterial', 'frameStyle',
            'lensWidthMm', 'bridgeWidthMm', 'templeLengthMm', 'lensHeightMm',
            'polarized', 'prescriptionAvailable', 'uvProtection'
        ];
        for (const field of fields) {
            const before = getFieldValue(field);
            const proposed = suggested[field] ?? '';

            const meta = fieldMeta[field] || { type: 'text' };
            const beforeNorm = meta.type === 'bool' ? (parseBool(before) === true ? '1' : '0') : before.trim();
            const proposedNorm = meta.type === 'bool'
                ? (parseBool(proposed) === true ? '1' : (parseBool(proposed) === false ? '0' : ''))
                : (proposed ?? '').toString().trim();
            const different = beforeNorm !== proposedNorm && proposedNorm !== '';
            const conf = typeof confidence[field] === 'number' ? confidence[field] : 0;

            const tr = document.createElement('tr');
            tr.dataset.field = field;

            const tdCheck = document.createElement('td');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'form-check-input gpt-field-check';
            checkbox.checked = !!different;
            tdCheck.appendChild(checkbox);

            const tdField = document.createElement('td');
            tdField.innerHTML = '<div class="fw-semibold">' + escapeText(field) + '</div><div class="small text-muted">confidence: ' + conf.toFixed(2) + '</div>';

            const tdBefore = document.createElement('td');
            tdBefore.style.whiteSpace = 'pre-wrap';
            tdBefore.textContent = before;

            const tdProposed = document.createElement('td');
            tdProposed.appendChild(createProposedInput(field, proposed));

            tr.appendChild(tdCheck);
            tr.appendChild(tdField);
            tr.appendChild(tdBefore);
            tr.appendChild(tdProposed);
            rowsEl.appendChild(tr);
        }
        diffEl.style.display = 'block';
    }

    function renderImages(payload) {
        clearImageRows();

        const images = Array.isArray(payload && payload.images) ? payload.images : [];
        let hasImageRows = false;

        if (images.length) {
            for (const img of images) {
                const url = img && img.url ? img.url.toString() : '';
                const label = img && img.label ? img.label.toString() : '';
                const colorTag = img && img.color ? img.color.toString() : '';
                if (!url || isBlank(url)) continue;

                if (!hasImageRows) {
                    const spacer = document.createElement('tr');
                    spacer.dataset.section = 'images-header';
                    spacer.innerHTML = '<td colspan="4" class="small text-muted">Images propos√©es (coche puis clique ‚ÄúT√©l√©charger et ajouter ces images‚Äù)</td>';
                    rowsEl.appendChild(spacer);
                }

                const tr = document.createElement('tr');
                tr.dataset.section = 'images';
                tr.dataset.url = url;
                if (colorTag && !isBlank(colorTag)) {
                    tr.dataset.colorTag = colorTag;
                }

                const tdCheck = document.createElement('td');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'form-check-input gpt-image-check';
                checkbox.checked = true;
                tdCheck.appendChild(checkbox);

                const tdField = document.createElement('td');
                tdField.innerHTML = '<div class="fw-semibold">image</div>' + (label ? ('<div class="small text-muted">' + escapeText(label) + '</div>') : '');

                const tdBefore = document.createElement('td');
                tdBefore.textContent = '';

                const tdProposed = document.createElement('td');

                const preview = document.createElement('img');
                preview.src = url;
                preview.alt = label || 'Aper√ßu';
                preview.loading = 'lazy';
                preview.referrerPolicy = 'no-referrer';
                preview.style.width = '44px';
                preview.style.height = '44px';
                preview.style.objectFit = 'cover';
                preview.style.borderRadius = '6px';
                preview.style.border = '1px solid rgba(0,0,0,.1)';
                preview.addEventListener('error', () => {
                    preview.style.display = 'none';
                });

                const link = document.createElement('a');
                link.href = url;
                link.target = '_blank';
                link.rel = 'noopener noreferrer';
                link.textContent = url;

                const wrapper = document.createElement('div');
                wrapper.className = 'd-flex align-items-center gap-2';
                wrapper.appendChild(preview);
                wrapper.appendChild(link);

                tdProposed.appendChild(wrapper);

                tr.appendChild(tdCheck);
                tr.appendChild(tdField);
                tr.appendChild(tdBefore);
                tr.appendChild(tdProposed);
                rowsEl.appendChild(tr);

                hasImageRows = true;
            }
        }

        if (!hasImageRows) {
            const spacer = document.createElement('tr');
            spacer.dataset.section = 'images-empty';
            spacer.innerHTML = '<td colspan="4" class="small text-muted">Images propos√©es : (aucune) ‚Äî active ‚Äúüîé Rechercher sur le web‚Äù ou renseigne un code-barres pour am√©liorer les r√©sultats.</td>';
            rowsEl.appendChild(spacer);
        }

        downloadImagesBtn.style.display = hasImageRows ? 'inline-block' : 'none';
    }

    function renderVariants(payload) {
        variantsRowsEl.innerHTML = '';

        const variants = Array.isArray(payload && payload.variants) ? payload.variants : [];
        if (variants.length) {
            for (const v of variants) {
                const name = v && v.name ? v.name.toString() : '';
                if (!name || isBlank(name)) continue;
                const tr = document.createElement('tr');
                tr.dataset.variant = JSON.stringify(v);
                tr.innerHTML = [
                    '<td><input type="checkbox" class="form-check-input gpt-variant-check" checked></td>',
                    '<td>' + escapeText(name) + '</td>',
                    '<td>' + escapeText((v && v.color ? v.color.toString() : '')) + '</td>',
                    '<td>' + escapeText((v && v.size ? v.size.toString() : '')) + '</td>',
                    '<td>' + escapeText((v && v.sku ? v.sku.toString() : '')) + '</td>',
                    '<td>' + escapeText((v && v.barcode ? v.barcode.toString() : '')) + '</td>',
                    '<td>' + escapeText((v && v.price !== undefined && v.price !== null) ? v.price.toString() : '') + '</td>',
                    '<td>' + escapeText((v && v.stock !== undefined && v.stock !== null) ? v.stock.toString() : '') + '</td>',
                    '<td class="gpt-variant-image-cell">'
                        + '<div class="d-flex align-items-center gap-2">'
                            + '<button type="button" class="btn btn-link btn-sm p-0 gpt-variant-retry">Relancer</button>'
                            + '<span class="small text-muted gpt-variant-image-status">‚Äî</span>'
                        + '</div>'
                    + '</td>'
                ].join('');
                variantsRowsEl.appendChild(tr);

                // Per-row retry (no page reload)
                const retryBtn = tr.querySelector('.gpt-variant-retry');
                if (retryBtn) {
                    retryBtn.addEventListener('click', async function () {
                        await generateImageForVariantRow(tr);
                    });
                }
            }

            const hasRows = variantsRowsEl.querySelectorAll('tr').length > 0;
            variantsEl.style.display = hasRows ? 'block' : 'none';
            createVariantsBtn.style.display = (hasRows && isEdit && productId && variantsEndpoint && variantsCsrf) ? 'inline-block' : 'none';
            generateVariantImagesBtn.style.display = (hasRows && isEdit && productId && variantImagesEndpoint && variantImagesCsrf) ? 'inline-block' : 'none';
        } else {
            variantsEl.style.display = 'none';
            createVariantsBtn.style.display = 'none';
            generateVariantImagesBtn.style.display = 'none';
        }
    }

    function getSelectedVariantRows() {
        const rows = Array.from(variantsRowsEl.querySelectorAll('tr'));
        return rows.filter(row => {
            const checkbox = row.querySelector('.gpt-variant-check');
            return !!(checkbox && checkbox.checked);
        });
    }

    function setVariantImageCellLoading(row, text) {
        const cell = row.querySelector('.gpt-variant-image-cell');
        if (!cell) return;

        // Keep retry button always available.
        let status = row.querySelector('.gpt-variant-image-status');
        if (!status) {
            cell.innerHTML = '';
            const wrap = document.createElement('div');
            wrap.className = 'd-flex align-items-center gap-2';
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'btn btn-link btn-sm p-0 gpt-variant-retry';
            btn.textContent = 'Relancer';
            btn.addEventListener('click', async function () {
                await generateImageForVariantRow(row);
            });
            status = document.createElement('span');
            status.className = 'small text-muted gpt-variant-image-status';
            wrap.appendChild(btn);
            wrap.appendChild(status);
            cell.appendChild(wrap);
        }

        status.className = 'small text-muted gpt-variant-image-status';
        status.textContent = text;

        const preview = row.querySelector('.gpt-variant-image-preview');
        if (preview) {
            preview.remove();
        }
    }

    function setVariantImageCellReady(row, text) {
        const cell = row.querySelector('.gpt-variant-image-cell');
        if (!cell) return;
        let status = row.querySelector('.gpt-variant-image-status');
        if (!status) {
            setVariantImageCellLoading(row, text);
            status = row.querySelector('.gpt-variant-image-status');
        }
        if (status) {
            status.className = 'badge bg-light text-dark gpt-variant-image-status';
            status.textContent = text;
        }
    }

    function setVariantImageCellError(row, text) {
        const cell = row.querySelector('.gpt-variant-image-cell');
        if (!cell) return;

        let status = row.querySelector('.gpt-variant-image-status');
        if (!status) {
            setVariantImageCellLoading(row, text);
            status = row.querySelector('.gpt-variant-image-status');
        }
        if (status) {
            status.className = 'small text-danger gpt-variant-image-status';
            status.textContent = text;
        }

        const preview = row.querySelector('.gpt-variant-image-preview');
        if (preview) {
            preview.remove();
        }
    }

    function setVariantImageCellPreview(row, localPath, sourceUrl) {
        const cell = row.querySelector('.gpt-variant-image-cell');
        if (!cell) return;

        // Ensure we keep the retry button + status line.
        let status = row.querySelector('.gpt-variant-image-status');
        if (!status) {
            setVariantImageCellLoading(row, 'OK');
            status = row.querySelector('.gpt-variant-image-status');
        }
        if (status) {
            status.className = 'badge bg-light text-dark gpt-variant-image-status';
            status.textContent = 'OK';
        }

        const existing = row.querySelector('.gpt-variant-image-preview');
        if (existing) existing.remove();

        const previewWrap = document.createElement('div');
        previewWrap.className = 'd-flex align-items-center gap-2 mt-1 gpt-variant-image-preview';

        const img = document.createElement('img');
        img.src = (localPath || '').toString();
        img.alt = 'Aper√ßu';
        img.loading = 'lazy';
        img.style.width = '44px';
        img.style.height = '44px';
        img.style.objectFit = 'cover';
        img.style.borderRadius = '6px';
        img.style.border = '1px solid rgba(0,0,0,.1)';
        img.addEventListener('error', () => {
            img.style.display = 'none';
        });
        previewWrap.appendChild(img);

        if (sourceUrl && !isBlank(sourceUrl.toString())) {
            const link = document.createElement('a');
            link.href = (sourceUrl || '').toString();
            link.target = '_blank';
            link.rel = 'noopener noreferrer';
            link.textContent = 'source';
            link.className = 'small';
            previewWrap.appendChild(link);
        }

        cell.appendChild(previewWrap);
    }

    function getVariantFromRow(row) {
        try {
            return JSON.parse((row.dataset.variant || '').toString());
        } catch (e) {
            return null;
        }
    }

    function isVariantReadyForServer(variant) {
        return !!(variant && variant.id && !Number.isNaN(parseInt(variant.id.toString(), 10)));
    }

    async function generateImageForVariantRow(row) {
        if (!isEdit || !variantImagesEndpoint || !variantImagesCsrf) return;

        const retryBtn = row.querySelector('.gpt-variant-retry');
        if (retryBtn) retryBtn.disabled = true;

        try {
            const variant = getVariantFromRow(row);
            if (!variant) {
                setVariantImageCellError(row, 'Donn√©es invalides.');
                return;
            }

            if (!isVariantReadyForServer(variant)) {
                setVariantImageCellError(row, 'Cr√©e la variante d\'abord.');
                return;
            }

            const options = {
                aggressiveness: aggressivenessEl.value,
                webSearch: !!webSearchEl.checked,
                language: 'fr',
                tone: 'luxury',
                variantImageCount: clampInt(variantImageCountEl.value, 1, 10, 1)
            };

            setVariantImageCellLoading(row, 'G√©n√©ration‚Ä¶');

            const res = await fetch(variantImagesEndpoint, {
                method: 'POST',
                headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
                body: JSON.stringify({ _csrf: variantImagesCsrf, variant: variant, options: options })
            });

            const data = await res.json().catch(() => null);
            if (!data) {
                setVariantImageCellError(row, 'HTTP ' + res.status);
                return;
            }
            if (!res.ok) {
                const msg = data && (data.message || data.error) ? (data.message || data.error).toString() : ('HTTP ' + res.status);
                setVariantImageCellError(row, msg);
                return;
            }

            if (data.ok) {
                const localPath = data.image && data.image.localPath ? data.image.localPath.toString() : '';
                const sourceUrl = data.sourceUrl ? data.sourceUrl.toString() : (data.image && data.image.sourceUrl ? data.image.sourceUrl.toString() : '');
                if (!isBlank(localPath)) {
                    setVariantImageCellPreview(row, localPath, sourceUrl);
                } else {
                    setVariantImageCellLoading(row, 'Ajout√© (sans aper√ßu).');
                }
            } else {
                const msg = data.error ? data.error.toString() : 'Erreur.';
                setVariantImageCellError(row, msg);
            }
        } catch (e) {
            setVariantImageCellError(row, 'Erreur r√©seau.');
        } finally {
            if (retryBtn) retryBtn.disabled = false;
        }
    }

    function getSelectedImages() {
        const rows = Array.from(rowsEl.querySelectorAll('tr'));
        const images = [];
        for (const row of rows) {
            if (!row.dataset.url) continue;
            const checkbox = row.querySelector('.gpt-image-check');
            if (checkbox && checkbox.checked) {
                const url = (row.dataset.url || '').toString();
                const colorTag = (row.dataset.colorTag || '').toString();
                if (!isBlank(url)) {
                    images.push({
                        url: url,
                        colorTag: !isBlank(colorTag) ? colorTag : null
                    });
                }
            }
        }
        return images;
    }

    function getSelectedVariants() {
        const rows = Array.from(variantsRowsEl.querySelectorAll('tr'));
        const variants = [];
        for (const row of rows) {
            const checkbox = row.querySelector('.gpt-variant-check');
            if (checkbox && checkbox.checked) {
                const raw = (row.dataset.variant || '').toString();
                try {
                    const v = JSON.parse(raw);
                    variants.push(v);
                } catch (e) {
                    // ignore
                }
            }
        }
        return variants;
    }

    function getSelectedRows() {
        const rows = Array.from(rowsEl.querySelectorAll('tr'));
        const selected = [];
        for (const row of rows) {
            const checkbox = row.querySelector('.gpt-field-check');
            if (checkbox && checkbox.checked) {
                selected.push(row);
            }
        }
        return selected;
    }

    applyEmptyBtn.addEventListener('click', function () {
        if (!lastSuggestion) return;
        for (const field of [
            'name', 'slug', 'brand', 'color', 'barcode', 'description', 'price', 'stock', 'category',
            'productType', 'gender', 'frameShape', 'frameMaterial', 'frameStyle',
            'lensWidthMm', 'bridgeWidthMm', 'templeLengthMm', 'lensHeightMm',
            'uvProtection'
        ]) {
            const current = getFieldValue(field);
            const row = rowsEl.querySelector('tr[data-field="' + field + '"]');
            const input = row ? row.querySelector('.gpt-proposed-input') : null;
            const proposed = input
                ? (input.type === 'checkbox' ? (input.checked ? true : false) : (input.value !== undefined ? input.value.toString() : ''))
                : '';
            if (isBlank(current) && !(typeof proposed === 'string' ? isBlank(proposed) : false)) {
                setFieldValue(field, proposed);
            }
        }
        showStatus('success', 'Champs vides appliqu√©s (rien n\'est sauvegard√© tant que vous ne cliquez pas sur Save).');
    });

    applySelectedBtn.addEventListener('click', function () {
        const rows = getSelectedRows();
        for (const row of rows) {
            const field = row.dataset.field;
            const input = row.querySelector('.gpt-proposed-input');
            const proposed = input
                ? (input.type === 'checkbox' ? (input.checked ? true : false) : (input.value !== undefined ? input.value.toString() : ''))
                : '';
            if (field && (typeof proposed === 'boolean' || !isBlank((proposed ?? '').toString()))) {
                setFieldValue(field, proposed);
            }
        }
        showStatus('success', 'S√©lection appliqu√©e (rien n\'est sauvegard√© tant que vous ne cliquez pas sur Save).');
    });

    copyDescriptionBtn.addEventListener('click', async function () {
        const row = rowsEl.querySelector('tr[data-field="description"]');
        const input = row ? row.querySelector('.gpt-proposed-input') : null;
        const proposed = input && input.value !== undefined ? input.value.toString() : '';
        if (isBlank(proposed)) {
            showStatus('warning', 'Aucune description propos√©e √† copier.');
            return;
        }
        try {
            await navigator.clipboard.writeText(proposed);
            showStatus('success', 'Description copi√©e.');
        } catch (e) {
            showStatus('warning', 'Copie impossible (permissions navigateur).');
        }
    });

    btn.addEventListener('click', async function () {
        clearStatus();
        diffEl.style.display = 'none';
        variantsEl.style.display = 'none';

        btn.disabled = true;
        btn.textContent = 'G√©n√©ration‚Ä¶';

        const categorySelect = qs(fieldSelectors.category);
        const categoryOptions = categorySelect ? Array.from(categorySelect.options || []).map(o => (o.textContent || '').toString().trim()).filter(Boolean) : [];

        const colorSelect = qs(fieldSelectors.color);
        const colorOptions = colorSelect ? Array.from(colorSelect.options || []).map(o => (o.textContent || '').toString().trim()).filter(Boolean) : [];

        const baseFields = {
                name: getFieldSendValue('name'),
                slug: getFieldSendValue('slug'),
                brand: getFieldSendValue('brand'),
                color: getFieldSendValue('color'),
                barcode: getFieldSendValue('barcode'),
                description: getFieldSendValue('description'),
                price: (qs(fieldSelectors.price) && qs(fieldSelectors.price).value !== undefined) ? qs(fieldSelectors.price).value : '',
                stock: (qs(fieldSelectors.stock) && qs(fieldSelectors.stock).value !== undefined) ? qs(fieldSelectors.stock).value : '',
                category: getFieldSendValue('category'),

                // Opticien
                productType: getFieldSendValue('productType'),
                gender: getFieldSendValue('gender'),
                frameShape: getFieldSendValue('frameShape'),
                frameMaterial: getFieldSendValue('frameMaterial'),
                frameStyle: getFieldSendValue('frameStyle'),
                lensWidthMm: getFieldSendValue('lensWidthMm'),
                bridgeWidthMm: getFieldSendValue('bridgeWidthMm'),
                templeLengthMm: getFieldSendValue('templeLengthMm'),
                lensHeightMm: getFieldSendValue('lensHeightMm'),
                polarized: getFieldSendValue('polarized'),
                prescriptionAvailable: getFieldSendValue('prescriptionAvailable'),
                uvProtection: getFieldSendValue('uvProtection'),
                categoryOptions: categoryOptions,
                colorOptions: colorOptions
        };

        const baseOptions = {
            aggressiveness: aggressivenessEl.value,
            webSearch: !!webSearchEl.checked,
            language: 'fr',
            tone: 'luxury',
            maxImages: clampInt(maxImagesEl.value, 1, 30, 20)
        };

        mergedSources = [];
        mergedNotes = [];
        lastSuggestion = { suggested: {}, confidence: {}, images: [], variants: [] };
        updateMetaDisplay();

        try {
            showStatus('info', 'G√©n√©ration du produit‚Ä¶');

            const res = await fetch(fieldsEndpoint, {
                method: 'POST',
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ _csrf: fieldsCsrf, fields: baseFields, options: baseOptions })
            });

            const data = await res.json().catch(() => null);
            if (!res.ok) {
                const msg = data && (data.message || data.error) ? (data.message || data.error) : ('HTTP ' + res.status);
                showStatus('danger', msg);
                return;
            }

            mergeMeta(data);
            renderFields(data);

            // Fire and forget: variants + images suggestions (progressive rendering)
            const imagesPromise = (imagesSuggestEndpoint && imagesSuggestCsrf)
                ? fetch(imagesSuggestEndpoint, {
                    method: 'POST',
                    headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
                    body: JSON.stringify({ _csrf: imagesSuggestCsrf, fields: baseFields, options: baseOptions })
                }).then(async r => ({ ok: r.ok, status: r.status, data: await r.json().catch(() => null) }))
                : Promise.resolve(null);

            const variantsPromise = (variantsSuggestEndpoint && variantsSuggestCsrf)
                ? fetch(variantsSuggestEndpoint, {
                    method: 'POST',
                    headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
                    body: JSON.stringify({ _csrf: variantsSuggestCsrf, fields: baseFields, options: baseOptions })
                }).then(async r => ({ ok: r.ok, status: r.status, data: await r.json().catch(() => null) }))
                : Promise.resolve(null);

            showStatus('info', 'Chargement des images et variantes‚Ä¶');

            const results = await Promise.allSettled([imagesPromise, variantsPromise]);

            const imgRes = results[0].status === 'fulfilled' ? results[0].value : null;
            if (imgRes && imgRes.ok && imgRes.data) {
                mergeMeta(imgRes.data);
                lastSuggestion.images = Array.isArray(imgRes.data.images) ? imgRes.data.images : [];
                renderImages({ images: lastSuggestion.images });
            } else {
                renderImages({ images: [] });
            }

            const varRes = results[1].status === 'fulfilled' ? results[1].value : null;
            if (varRes && varRes.ok && varRes.data) {
                mergeMeta(varRes.data);
                lastSuggestion.variants = Array.isArray(varRes.data.variants) ? varRes.data.variants : [];
                renderVariants({ variants: lastSuggestion.variants });
            } else {
                renderVariants({ variants: [] });
            }

            showStatus('success', 'Suggestion termin√©e.');
        } catch (e) {
            showStatus('danger', 'Erreur r√©seau lors de la suggestion.');
        } finally {
            btn.disabled = false;
            btn.textContent = '‚ú® Am√©liorer avec GPT';
        }
    });

    downloadImagesBtn.addEventListener('click', async function () {
        const images = getSelectedImages();
        if (!images.length) {
            showStatus('warning', 'Aucune image s√©lectionn√©e.');
            return;
        }
        downloadImagesBtn.disabled = true;
        try {
            const targetEndpoint = (isEdit && imagesEndpoint) ? imagesEndpoint : imagesStageEndpoint;
            const targetCsrf = (isEdit && imagesCsrf) ? imagesCsrf : imagesStageCsrf;
            if (!targetEndpoint || !targetCsrf) {
                showStatus('danger', 'Endpoint images non configur√©.');
                return;
            }

            const res = await fetch(targetEndpoint, {
                method: 'POST',
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ _csrf: targetCsrf, images: images })
            });
            const data = await res.json().catch(() => null);
            if (!res.ok) {
                const msg = data && (data.message || data.error) ? (data.message || data.error) : ('HTTP ' + res.status);
                showStatus('danger', msg);
                return;
            }

            if (isEdit) {
                const added = data && typeof data.added === 'number' ? data.added : 0;
                showStatus('success', 'Images ajout√©es: ' + added + ' (rafra√Æchis la page pour voir les thumbnails).');
            } else {
                const token = data && data.token ? data.token.toString() : '';
                if (token) {
                    setStagedImagesToken(token);
                }
                const downloaded = data && Array.isArray(data.downloaded) ? data.downloaded.length : 0;
                showStatus('success', 'Images t√©l√©charg√©es: ' + downloaded + '. Elles seront ajout√©es lors de l\'enregistrement du produit (Save).');
            }
        } catch (e) {
            showStatus('danger', 'Erreur r√©seau lors de l\'ajout des images.');
        } finally {
            downloadImagesBtn.disabled = false;
        }
    });

    createVariantsBtn.addEventListener('click', async function () {
        if (!isEdit || !variantsEndpoint || !variantsCsrf) return;
        const variants = getSelectedVariants();
        if (!variants.length) {
            showStatus('warning', 'Aucune variante s√©lectionn√©e.');
            return;
        }
        createVariantsBtn.disabled = true;
        try {
            const res = await fetch(variantsEndpoint, {
                method: 'POST',
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ _csrf: variantsCsrf, variants: variants })
            });
            const data = await res.json().catch(() => null);
            if (!res.ok) {
                const msg = data && (data.message || data.error) ? (data.message || data.error) : ('HTTP ' + res.status);
                showStatus('danger', msg);
                return;
            }

            // Attach variant ids to the UI rows so subsequent image generation can target by id.
            const returned = []
                .concat(Array.isArray(data && data.createdVariants) ? data.createdVariants : [])
                .concat(Array.isArray(data && data.updatedVariants) ? data.updatedVariants : []);

            const bySku = {};
            const byBarcode = {};
            const byNameKey = {};

            function normStr(v) { return (v ?? '').toString().trim().toLowerCase(); }
            function normBarcode(v) { return (v ?? '').toString().replace(/\D+/g, '').trim(); }
            function nameKey(v) {
                const n = normStr(v && v.name);
                const c = normStr(v && v.color);
                const s = normStr(v && v.size);
                return n + '|' + c + '|' + s;
            }

            for (const r of returned) {
                const id = r && r.id !== undefined && r.id !== null ? parseInt(r.id.toString(), 10) : 0;
                if (!id || Number.isNaN(id)) continue;
                const sku = normStr(r && r.sku);
                const bc = normBarcode(r && r.barcode);
                if (sku) bySku[sku] = id;
                if (bc) byBarcode[bc] = id;
                const k = nameKey(r);
                if (k !== '||') byNameKey[k] = id;
            }

            const rows = getSelectedVariantRows();
            for (const row of rows) {
                let v = null;
                try { v = JSON.parse((row.dataset.variant || '').toString()); } catch (e) { v = null; }
                if (!v) continue;

                const sku = normStr(v && v.sku);
                const bc = normBarcode(v && v.barcode);
                const k = nameKey(v);

                const id = (sku && bySku[sku])
                    ? bySku[sku]
                    : ((bc && byBarcode[bc]) ? byBarcode[bc] : (byNameKey[k] || 0));

                if (id && !Number.isNaN(id)) {
                    v.id = id;
                    row.dataset.variant = JSON.stringify(v);
                    setVariantImageCellReady(row, 'Variante pr√™te');
                }
            }

            const created = data && typeof data.created === 'number' ? data.created : 0;
            const updated = data && typeof data.updated === 'number' ? data.updated : 0;
            const skipped = data && typeof data.skipped === 'number' ? data.skipped : 0;
            const errs = Array.isArray(data && data.errors) ? data.errors : [];

            let msg = 'Variantes: ' + created + ' cr√©√©e(s), ' + updated + ' mise(s) √† jour';
            if (skipped) msg += ', ' + skipped + ' ignor√©e(s)';
            msg += '.';
            if (errs.length) msg += ' ' + errs.slice(0, 2).join(' | ');
            showStatus(errs.length ? 'warning' : 'success', msg);
        } catch (e) {
            showStatus('danger', 'Erreur r√©seau lors de la cr√©ation des variantes.');
        } finally {
            createVariantsBtn.disabled = false;
        }
    });

    generateVariantImagesBtn.addEventListener('click', async function () {
        if (!isEdit || !variantImagesEndpoint || !variantImagesCsrf) return;
        const rows = getSelectedVariantRows();
        if (!rows.length) {
            showStatus('warning', 'Aucune variante s√©lectionn√©e.');
            return;
        }
        generateVariantImagesBtn.disabled = true;

        let okCount = 0;
        let failCount = 0;
        try {
            showStatus('info', 'G√©n√©ration des images par variante‚Ä¶');

            for (const row of rows) {
                const before = (row.querySelector('.gpt-variant-image-status')?.textContent || '').toString();
                await generateImageForVariantRow(row);
                const after = (row.querySelector('.gpt-variant-image-status')?.textContent || '').toString();
                // Best-effort counters
                if (after && after !== before && after !== 'G√©n√©ration‚Ä¶') {
                    if (after.toLowerCase().includes('erreur') || after.toLowerCase().includes('aucune') || after.toLowerCase().includes('cr√©e')) {
                        failCount++;
                    } else {
                        okCount++;
                    }
                }
            }

            showStatus('success', 'Images variantes: ' + okCount + ' ok, ' + failCount + ' √©chec.');
        } catch (e) {
            showStatus('danger', 'Erreur r√©seau lors de la g√©n√©ration des images variantes.');
        } finally {
            generateVariantImagesBtn.disabled = false;
        }
    });
})();
</script>
